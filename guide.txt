# OBDA实证分析实验：通过大学数据库案例理解本体推理

## 1. 实验目标

本实验旨在通过一个简单的大学数据库案例，向读者直观展示：
- OBDA如何将关系数据库映射到语义层
- 本体推理如何丰富查询结果
- SPARQL查询如何转换为SQL查询
- 为什么OBDA能提供更智能的数据访问

## 2. 案例背景：大学人员管理系统

假设我们有一个传统的大学数据库，存储着教职工和学生信息。数据库设计时没有考虑到概念层次，只是简单地按照部门需求创建了表格。现在我们要通过OBDA技术，为这个数据库添加语义层，使其能够回答更智能的查询。

### 2.1 原始数据库结构

```sql
-- 员工表（由人事部门管理）
CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100),
    department VARCHAR(50),
    position VARCHAR(50),
    salary DECIMAL(10,2)
);

-- 教学记录表（由教务部门管理）
CREATE TABLE teaching_records (
    record_id INT PRIMARY KEY,
    emp_id INT,
    course_code VARCHAR(20),
    course_name VARCHAR(100),
    semester VARCHAR(20),
    FOREIGN KEY (emp_id) REFERENCES employees(emp_id)
);

-- 学生表（由学籍管理部门管理）
CREATE TABLE students (
    student_id INT PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100),
    major VARCHAR(50),
    year INT,
    advisor_id INT,
    FOREIGN KEY (advisor_id) REFERENCES employees(emp_id)
);

-- 研究生表（由研究生院管理）
CREATE TABLE graduate_students (
    student_id INT PRIMARY KEY,
    thesis_title VARCHAR(200),
    defense_date DATE,
    research_area VARCHAR(100),
    FOREIGN KEY (student_id) REFERENCES students(student_id)
);
```

### 2.2 示例数据

```sql
-- 插入员工数据
INSERT INTO employees VALUES 
(1, 'Alice Wang', 'alice@uni.edu', 'Computer Science', 'Professor', 120000),
(2, 'Bob Chen', 'bob@uni.edu', 'Computer Science', 'Associate Professor', 90000),
(3, 'Carol Liu', 'carol@uni.edu', 'Mathematics', 'Professor', 115000),
(4, 'David Zhang', 'david@uni.edu', 'Computer Science', 'Lecturer', 70000),
(5, 'Emma Li', 'emma@uni.edu', 'Administration', 'Staff', 50000);

-- 插入教学记录
INSERT INTO teaching_records VALUES
(1, 1, 'CS101', 'Introduction to Programming', '2024 Fall'),
(2, 1, 'CS501', 'Advanced Algorithms', '2024 Fall'),
(3, 2, 'CS201', 'Data Structures', '2024 Fall'),
(4, 3, 'MATH101', 'Calculus I', '2024 Fall'),
(5, 4, 'CS101', 'Introduction to Programming', '2024 Fall');

-- 插入学生数据
INSERT INTO students VALUES
(101, 'Frank Zhou', 'frank@stu.uni.edu', 'Computer Science', 2022, 1),
(102, 'Grace Ma', 'grace@stu.uni.edu', 'Computer Science', 2023, 2),
(103, 'Henry Wu', 'henry@stu.uni.edu', 'Mathematics', 2022, 3),
(104, 'Ivy Chen', 'ivy@stu.uni.edu', 'Computer Science', 2021, 1);

-- 插入研究生数据
INSERT INTO graduate_students VALUES
(104, 'Machine Learning for Healthcare', '2024-06-15', 'Artificial Intelligence');
```

## 3. 本体设计：添加语义层

### 3.1 核心概念

我们设计一个简单但富有表现力的本体，包含以下核心概念：

```turtle
@prefix : <http://example.org/university#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

# 类定义
:Person a owl:Class .
:Employee a owl:Class ; rdfs:subClassOf :Person .
:Student a owl:Class ; rdfs:subClassOf :Person .
:UndergraduateStudent a owl:Class ; rdfs:subClassOf :Student .
:GraduateStudent a owl:Class ; rdfs:subClassOf :Student .

# 员工子类
:AcademicStaff a owl:Class ; rdfs:subClassOf :Employee .
:AdministrativeStaff a owl:Class ; rdfs:subClassOf :Employee .
:Professor a owl:Class ; rdfs:subClassOf :AcademicStaff .
:AssociateProfessor a owl:Class ; rdfs:subClassOf :AcademicStaff .
:Lecturer a owl:Class ; rdfs:subClassOf :AcademicStaff .

# 属性定义
:hasName a owl:DatatypeProperty .
:hasEmail a owl:DatatypeProperty .
:teaches a owl:ObjectProperty .
:hasAdvisor a owl:ObjectProperty .
:worksInDepartment a owl:DatatypeProperty .

# 推理规则（使用OWL构造）
:Teacher owl:equivalentClass [
    a owl:Class ;
    owl:intersectionOf (
        :Employee
        [ a owl:Restriction ;
          owl:onProperty :teaches ;
          owl:someValuesFrom :Course ]
    )
] .

# 课程相关
:Course a owl:Class .
:UndergraduateCourse a owl:Class ; rdfs:subClassOf :Course .
:GraduateCourse a owl:Class ; rdfs:subClassOf :Course .
```

### 3.2 映射规则（R2RML格式）

```turtle
@prefix rr: <http://www.w3.org/ns/r2rml#> .
@prefix ex: <http://example.org/university#> .

# 映射1：教授（position = 'Professor'）
<#ProfessorMapping>
    rr:logicalTable [ rr:sqlQuery """
        SELECT emp_id, name, email, department 
        FROM employees 
        WHERE position = 'Professor'
    """ ] ;
    rr:subjectMap [
        rr:template "http://example.org/university#employee/{emp_id}" ;
        rr:class ex:Professor
    ] ;
    rr:predicateObjectMap [
        rr:predicate ex:hasName ;
        rr:objectMap [ rr:column "name" ]
    ] ;
    rr:predicateObjectMap [
        rr:predicate ex:hasEmail ;
        rr:objectMap [ rr:column "email" ]
    ] .

# 映射2：副教授
<#AssociateProfessorMapping>
    rr:logicalTable [ rr:sqlQuery """
        SELECT emp_id, name, email, department 
        FROM employees 
        WHERE position = 'Associate Professor'
    """ ] ;
    rr:subjectMap [
        rr:template "http://example.org/university#employee/{emp_id}" ;
        rr:class ex:AssociateProfessor
    ] ;
    rr:predicateObjectMap [
        rr:predicate ex:hasName ;
        rr:objectMap [ rr:column "name" ]
    ] .

# 映射3：行政人员
<#AdminStaffMapping>
    rr:logicalTable [ rr:sqlQuery """
        SELECT emp_id, name, email 
        FROM employees 
        WHERE department = 'Administration'
    """ ] ;
    rr:subjectMap [
        rr:template "http://example.org/university#employee/{emp_id}" ;
        rr:class ex:AdministrativeStaff
    ] ;
    rr:predicateObjectMap [
        rr:predicate ex:hasName ;
        rr:objectMap [ rr:column "name" ]
    ] .

# 映射4：教学关系
<#TeachingMapping>
    rr:logicalTable [ rr:sqlQuery """
        SELECT emp_id, course_code, course_name 
        FROM teaching_records
    """ ] ;
    rr:subjectMap [
        rr:template "http://example.org/university#employee/{emp_id}"
    ] ;
    rr:predicateObjectMap [
        rr:predicate ex:teaches ;
        rr:objectMap [
            rr:template "http://example.org/university#course/{course_code}"
        ]
    ] .

# 映射5：研究生
<#GraduateStudentMapping>
    rr:logicalTable [ rr:sqlQuery """
        SELECT s.student_id, s.name, s.email, g.thesis_title
        FROM students s
        JOIN graduate_students g ON s.student_id = g.student_id
    """ ] ;
    rr:subjectMap [
        rr:template "http://example.org/university#student/{student_id}" ;
        rr:class ex:GraduateStudent
    ] ;
    rr:predicateObjectMap [
        rr:predicate ex:hasName ;
        rr:objectMap [ rr:column "name" ]
    ] .

# 映射6：本科生（通过排除法）
<#UndergraduateStudentMapping>
    rr:logicalTable [ rr:sqlQuery """
        SELECT s.student_id, s.name, s.email
        FROM students s
        WHERE NOT EXISTS (
            SELECT 1 FROM graduate_students g 
            WHERE g.student_id = s.student_id
        )
    """ ] ;
    rr:subjectMap [
        rr:template "http://example.org/university#student/{student_id}" ;
        rr:class ex:UndergraduateStudent
    ] ;
    rr:predicateObjectMap [
        rr:predicate ex:hasName ;
        rr:objectMap [ rr:column "name" ]
    ] .
```

## 4. 核心实验：展示推理的威力

### 4.1 查询对比实验

我们通过一系列查询来展示OBDA的推理能力：

#### 查询1：找出所有人员（展示类层次推理）

**SPARQL查询：**
```sparql
PREFIX ex: <http://example.org/university#>

SELECT ?person ?name
WHERE {
    ?person a ex:Person ;
            ex:hasName ?name .
}
```

**不使用推理时：** 返回0条结果（因为没有直接声明为Person的实例）

**使用推理时：** 返回9条结果（所有员工和学生，因为Employee和Student都是Person的子类）

**生成的SQL（使用推理）：**
```sql
-- Ontop会生成类似这样的UNION查询
SELECT CONCAT('employee/', emp_id) as person, name 
FROM employees
UNION
SELECT CONCAT('student/', student_id) as person, name 
FROM students
```

#### 查询2：找出所有学术人员（展示多层推理）

**SPARQL查询：**
```sparql
PREFIX ex: <http://example.org/university#>

SELECT ?staff ?name ?position
WHERE {
    ?staff a ex:AcademicStaff ;
           ex:hasName ?name .
}
```

**不使用推理时：** 返回0条结果

**使用推理时：** 返回4条结果（所有教授、副教授和讲师）

#### 查询3：找出所有教师（展示等价类推理）

**SPARQL查询：**
```sparql
PREFIX ex: <http://example.org/university#>

SELECT DISTINCT ?teacher ?name
WHERE {
    ?teacher a ex:Teacher ;
             ex:hasName ?name .
}
```

**解释：** Teacher被定义为"有教学记录的员工"，这展示了通过属性来定义类的能力。

## 5. 环境搭建指南

### 5.1 安装Ontop

```bash
# 1. 下载Ontop CLI
wget https://github.com/ontop/ontop/releases/download/ontop-5.0.2/ontop-cli-5.0.2.zip
unzip ontop-cli-5.0.2.zip

# 2. 下载MySQL JDBC驱动
wget https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-java-8.0.33.zip
unzip mysql-connector-java-8.0.33.zip
cp mysql-connector-java-8.0.33/mysql-connector-java-8.0.33.jar ontop-cli-5.0.2/jdbc/
```

### 5.2 创建配置文件

**university.properties:**
```properties
jdbc.url=jdbc:mysql://localhost:3306/university_demo
jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.user=root
jdbc.password=yourpassword

# 启用推理
ontop.enableDefaultDatatypeInference=true
```

### 5.3 创建映射文件（.obda格式）

**university.obda:**
```
[PrefixDeclaration]
:		http://example.org/university#
owl:		http://www.w3.org/2002/07/owl#
rdfs:		http://www.w3.org/2000/01/rdf-schema#

[MappingDeclaration] @collection [[
mappingId	Professor
target		:employee/{emp_id} a :Professor ; :hasName {name} ; :hasEmail {email} .
source		SELECT emp_id, name, email FROM employees WHERE position = 'Professor'

mappingId	AssociateProfessor  
target		:employee/{emp_id} a :AssociateProfessor ; :hasName {name} .
source		SELECT emp_id, name, email FROM employees WHERE position = 'Associate Professor'

mappingId	Teaching
target		:employee/{emp_id} :teaches :course/{course_code} .
source		SELECT emp_id, course_code FROM teaching_records

mappingId	GraduateStudent
target		:student/{student_id} a :GraduateStudent ; :hasName {name} .
source		SELECT s.student_id, s.name FROM students s JOIN graduate_students g ON s.student_id = g.student_id
]]
```

## 6. 运行实验

### 6.1 启动Ontop SPARQL端点

```bash
./ontop endpoint \
    --ontology=university.ttl \
    --mapping=university.obda \
    --properties=university.properties \
    --port=8080
```

### 6.2 执行查询比较

```bash
# 查询所有Person（展示推理）
curl -X POST http://localhost:8080/sparql \
  -H "Content-Type: application/sparql-query" \
  -d "PREFIX ex: <http://example.org/university#>
      SELECT ?person ?name WHERE { 
          ?person a ex:Person ; ex:hasName ?name 
      }"
```

## 7. 实验结果分析

### 7.1 推理效果对比表

| 查询目标 | 不使用推理 | 使用推理 | 推理类型 |
|---------|-----------|----------|----------|
| 查询所有Person | 0条 | 9条 | 子类推理 |
| 查询所有AcademicStaff | 0条 | 4条 | 多层子类推理 |
| 查询所有Teacher | 0条 | 3条 | 等价类推理 |
| 查询所有Employee | 0条 | 5条 | 子类推理 |

### 7.2 关键观察

1. **透明性**：用户无需了解底层数据库结构，只需理解领域概念
2. **智能性**：系统自动推理出隐含的关系
3. **灵活性**：新增概念无需修改数据库结构
4. **统一性**：分散在多个表中的数据通过统一的概念模型访问

## 8. 进阶实验：查询重写可视化

使用Ontop的调试模式查看SPARQL如何转换为SQL：

```bash
./ontop query \
    --ontology=university.ttl \
    --mapping=university.obda \
    --properties=university.properties \
    --query="SELECT ?p ?n WHERE { ?p a :Person ; :hasName ?n }" \
    --log-level=DEBUG
```

这将显示详细的查询重写过程，帮助理解OBDA的内部工作机制。

## 9. 总结

通过这个简单的大学数据库案例，我们展示了：
1. OBDA如何将传统关系数据库提升为智能知识库
2. 本体推理如何使查询更加智能和灵活
3. 用户如何通过概念层而非物理层访问数据
4. 为什么OBDA是企业数据集成的有力工具